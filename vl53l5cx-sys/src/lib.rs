#![no_std]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

// Include the bindings generated by build.rs
include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

// Export the safe wrapper module.
pub mod wrappers;

// The C struct `VL53L5CX_Configuration` does not derive Default.
// We need to implement it manually so that it can be easily initialized.
impl Default for VL53L5CX_Configuration {
    fn default() -> Self {
        // Safe way to create a zero-initialized struct.
        unsafe { core::mem::zeroed() }
    }
}

// --- MANUAL CONSTANT DEFINITIONS ---
// Bindgen often skips macros with explicit casts (e.g. ((uint8_t)0U)).
// We define them manually here to ensure they are available to the driver.

// Status Codes
pub const VL53L5CX_STATUS_OK: u8 = 0;
pub const VL53L5CX_STATUS_TIMEOUT_ERROR: u8 = 1;
pub const VL53L5CX_STATUS_CORRUPTED_FRAME: u8 = 2;
pub const VL53L5CX_STATUS_CRC_CSUM_FAILED: u8 = 3;
pub const VL53L5CX_STATUS_XTALK_FAILED: u8 = 4;
pub const VL53L5CX_MCU_ERROR: u8 = 66;
pub const VL53L5CX_STATUS_INVALID_PARAM: u8 = 127;
pub const VL53L5CX_STATUS_ERROR: u8 = 255;

// Resolution
pub const VL53L5CX_RESOLUTION_4X4: u8 = 16;
pub const VL53L5CX_RESOLUTION_8X8: u8 = 64;

// Target Order
pub const VL53L5CX_TARGET_ORDER_CLOSEST: u8 = 1;
pub const VL53L5CX_TARGET_ORDER_STRONGEST: u8 = 2;

// Ranging Mode
pub const VL53L5CX_RANGING_MODE_CONTINUOUS: u8 = 1;
pub const VL53L5CX_RANGING_MODE_AUTONOMOUS: u8 = 3;

// Power Mode
pub const VL53L5CX_POWER_MODE_SLEEP: u8 = 0;
pub const VL53L5CX_POWER_MODE_WAKEUP: u8 = 1;

// Default Address
pub const VL53L5CX_DEFAULT_I2C_ADDRESS: u16 = 0x52;

// Thresholds & Detection (Plugin Constants)
#[cfg(feature = "thresholds")]
pub mod thresholds {
    pub const VL53L5CX_NB_THRESHOLDS: u8 = 64;
    pub const VL53L5CX_LAST_THRESHOLD: u8 = 128;
    
    // Detection Threshold Types
    pub const VL53L5CX_IN_WINDOW: u8 = 0;
    pub const VL53L5CX_OUT_OF_WINDOW: u8 = 1;
    pub const VL53L5CX_LESS_THAN_EQUAL_MIN_CHECKER: u8 = 2;
    pub const VL53L5CX_GREATER_THAN_MAX_CHECKER: u8 = 3;
    pub const VL53L5CX_EQUAL_MIN_CHECKER: u8 = 4;
    pub const VL53L5CX_NOT_EQUAL_MIN_CHECKER: u8 = 5;

    // Measurements
    pub const VL53L5CX_DISTANCE_MM: u8 = 1;
    pub const VL53L5CX_SIGNAL_PER_SPAD_KCPS: u8 = 2;
    pub const VL53L5CX_RANGE_SIGMA_MM: u8 = 4;
    pub const VL53L5CX_AMBIENT_PER_SPAD_KCPS: u8 = 8;
    pub const VL53L5CX_NB_TARGET_DETECTED: u8 = 9;
    pub const VL53L5CX_NB_SPADS_ENABLED: u8 = 10;
    pub const VL53L5CX_MOTION_INDICATOR: u8 = 11;
    pub const VL53L5CX_TARGET_STATUS: u8 = 12;

    // Operations
    pub const VL53L5CX_OPERATION_NONE: u8 = 0;
    pub const VL53L5CX_OPERATION_OR: u8 = 0; // Same as NONE in C source (idx 0) but logically OR for first element
    pub const VL53L5CX_OPERATION_AND: u8 = 1;
}

// Re-export threshold constants to top level if feature is enabled
#[cfg(feature = "thresholds")]
pub use thresholds::*;